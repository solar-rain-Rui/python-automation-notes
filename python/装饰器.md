
### 闭包

全局变量太容易被修改；而局部变量由于作用域受限，访问受控(外部代码无法直接访问或修改一个函数的局部变量，只能通过函数的返回值或参数来传递数据)，更加安全不易被修改


#### 定义

定义双层嵌套函数，内层函数可以访问外层函数的变量

将内层函数作为外层函数的返回，此内层函数就是闭包函数

#### 优缺点

优点：
- 无需定义全局变量即可实现通过函数持续的访问、修改某个值
- 闭包函数引用的外部变量，是外层函数的内部变量。作用域封闭难以被污操作修改

缺点：
- 由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放，一直占用内存

#### nonlocal关键字的作用

在闭包函数(内部函数)中，想要修改外部函数的变量值
需要用nonlocal声明这个外部变量


### 装饰器

装饰器就是"专门用来包装函数的闭包“

在不破坏目标函数原有的代码和功能的前提下，为目标函数增加额外新功能

#### 装饰器的写法

```python

#装饰器的一般写法(闭包写法)示例
def outer(func):
	def inner():
		print("睡觉")
		func()
		print("起床")
	return inner
	
def sleep():
	print("睡眠中...")
	
fn=outer(sleep)

#装饰器的快捷写法语法糖示例
#使用@outer定义在目标函数sleep之上
def outer(func):
	def inner():
		print("睡觉")
		func()
		print("起床")
	return inner

@outer
def sleep():
	print("睡眠中...")

sleep()
#outer是一个装饰器函数，它接收一个函数func作为参数
#当python执行@outer时，相当于执行sleep=outer(func)
#所以执行完装饰器后，sleep不再指向原来函数，指向了返回的inner函数
#因此当调用sleep()时，实际上调用的是inner()
```

这样当用户调用被装饰的函数时，实际上调用的是包装后的新函数，从而在不修改原函数的情况下实现了功能增强

##### 示例拆解

```python
#分步拆解
def my_decorator(func):
    print(f"步骤1: 装饰器被调用，开始定义wrapper")
    
    def wrapper():
        print("步骤3: wrapper函数体内的逻辑 - 这会在未来被调用")
        func()  # 调用原始函数
        print("步骤5: wrapper函数体内的逻辑 - 这会在未来被调用")
    
    print("步骤2: 装饰器返回wrapper函数（注意：不是调用wrapper()）")
    return wrapper

print("开始应用装饰器...")
@my_decorator        # 这里会执行步骤1和步骤2
def say_hello():
    print("步骤4: 原始函数逻辑")

print("=== 调用阶段 ===")
say_hello()      #这里才会执行步骤3、4、5
```

1. 当Python解释器遇到@my_decorator时，它会立即执行my_decorator函数，并将被装饰的函数（say_hello）作为参数传入
2. 在my_decorator函数内部，定义了一个wrapper函数，但是注意，定义函数并不会执行函数体
3. 然后，my_decorator返回wrapper函数对象（注意没有调用wrapper函数，所以不会执行wrapper函数体内的代码）
4. 最后，将返回的wrapper函数对象赋值给say_hello这个函数名
5. 所以在调用say_hello()的时候，实际上调用的是wrapper函数，然后才执行wrapper函数内部的代码

**小结**：

阶段一：模块加载/定义时（只发生一次）
	时间点：Python解释器遇到@decorator时
	动作：执行decorator函数，返回wrapper函数对象
	效果：say_hello名字现在指向wrapper函数

阶段二：函数调用时（每次调用都发生）
	时间点：代码中调用say_hello()时
	动作：执行wrapper函数体内的代码
	效果：执行增强逻辑+原始函数逻辑