
### QA

#### Q:为什么我不传proxies这个代理的参数，fidder也能抓到包？

Fiddler 能抓到请求包，和你是否在代码中设置 `proxies` 参数无关，核心原因是 **Fiddler 工作在 “系统 / 全局代理” 层面**，而不是依赖代码中显式设置的代理参数

**抓包原理**：Fiddler 本质是一个 “代理服务器”，但它的工作方式是 **“全局代理劫持”**：  
当你启动 Fiddler 并开启抓包时，它会自动修改你的 **系统网络设置**（包括浏览器、Python 程序等所有应用的网络连接），让你的电脑上所有的 HTTP/HTTPS 请求，都必须先经过 Fiddler 转发才能到达目标服务器。

 `proxies` 参数的作用：手动指定局部代理（非必需）

代码中设置 `proxies`（如 `requests.get(url, proxies={"http": "http://127.0.0.1:8888"})`），是 **“手动指定代理”** 的方式，主要用于两种场景：
- 你的系统没有全局代理（如 Fiddler 未启动或未配置），但你希望某个请求单独走代理；
- 系统已有全局代理，但你希望某个请求绕过全局代理，走自己指定的代理。
但当 Fiddler 已经启动并设置了 **系统全局代理** 时，即使你不写 `proxies` 参数，Python 的 `requests` 库也会 **自动继承系统的代理设置**，所以请求依然会经过 Fiddler，自然能被抓到。

#### Q:中文乱码？

A：当使用 `requests` 发送字符串类型的数据（如通过 `data` 参数传递）时，如果未指定编码

方式，`requests` 会默认使用 `latin-1` 编码将字符串转换为字节串（bytes）后放入 HTTP 请求体中，会导致**中文等非 ASCII 字符出现乱码**，因为 `latin-1` 编码仅支持 ASCII 字符及部分西欧语言，无法正确编码中文（会直接丢弃或替换为无效字符）
发送含中文的字符串时，**避免依赖 `requests` 的默认编码（`latin-1`）**

[[note1#^01|字符串与字节串概念]]
##### 如何正确处理中文？

解决方法是**手动指定编码为 `utf-8`**（支持全球绝大多数语言，包括中文）

 1. 提前将字符串用 `utf-8` 编码为字节串
	 在传入 `requests` 前，主动将字符串通过 `str.encode('utf-8')` 转换为字节串，避免 `requests` 使用默认的 `latin-1`
2. 使用 `json` 参数（适用于 JSON 格式数据）
	如果发送的是 JSON 格式数据（含中文），推荐使用 `json` 参数而非 `data` 参数，
	`requests` 会**自动将数据序列化为 JSON 字符串，并使用 `utf-8` 编码**，同时自动添
	加 `Content-Type: application/json` 头

#### response对象中的content和text区别？
^02

A：`response.content` 返回的是原始的、未解码的字节序列（bytes），而 `response.text` 返回的是经过解码的字符串（str）

|特性|`response.content`|`response.text`|
|---|---|---|
|**数据类型**|`bytes` （字节）|`str` （字符串）|
|**处理方式**|**原始**的 HTTP 响应体，未经任何处理|对 `content` 进行**解码**后得到的字符串|
|**编码**|与编码无关，就是二进制数据|依赖 **`response.encoding`** 的值进行解码|
|**适用场景**|非文本内容（图片、视频、压缩文件等）|文本内容（HTML、JSON、XML 等）|
|**性能**|更快，因为没有解码开销|稍慢，因为需要解码操作|
##### response.content

- **是什么**：这是服务器返回的最原始的数据。网络传输的本质是二进制流（0和1），`content` 就是直接接收到的这个二进制流，被 Python 封装成了 `bytes` 对象。
    
- **怎么看**：打印出来时，因为它是字节，所以你会看到很多像 `b'\x1f\x8b\x08...'` 或 `b'<!DOCTYPE html...'` 这样的形式。开头的 `b` 表示这是一个 bytes 字面量。
    
- **什么时候用**： 当你下载**非文本文件**时，必须使用 `.content`。比如下载图片、PDF、视频等。

##### response.text

- **是什么**：这是一个非常方便的属性。`requests` 库会尝试根据 HTTP 头信息或内容本身来**猜测**响应的编码（如 UTF-8, GBK, ISO-8859-1 等），然后用这个编码将 `response.content`（字节）**解码**成人类可读的字符串（str）。
    
- **编码是关键**：`response.text` 的解码行为依赖于 `response.encoding` 这个属性。如果 `encoding` 设置错了，`.text` 返回的就是一堆乱码。
    
- **什么时候用**：当你处理**文本内容**时，比如获取网页 HTML、API 返回的 JSON 字符串等。
